import { MetadataRoute } from 'next';
import { SITE_URL } from '@/lib/site';
import { getAllProducts } from '@/lib/api/products';
import { getAllCategories } from '@/lib/api/categories';
import { LOCALES, DEFAULT_LOCALE } from '@/types/sitemap';

// Helper to generate alternate language URLs
function generateAlternateUrls(path: string) {
  return LOCALES.reduce((acc, locale) => ({
    ...acc,
    [locale]: `${SITE_URL}${locale === DEFAULT_LOCALE ? '' : `/${locale}`}${path}`,
  }), {});
}

// Static pages that don't change often
function getStaticPages() {
  const staticRoutes = [
    { path: '/', priority: 1.0 },
    { path: '/about', priority: 0.8 },
    { path: '/contacts', priority: 0.8 },
    { path: '/catalog', priority: 0.9 },
    { path: '/services', priority: 0.7 },
    { path: '/blog', priority: 0.7 },
  ];

  return staticRoutes.flatMap(({ path, priority }) =>
    LOCALES.map((locale) => ({
      url: `${SITE_URL}${locale === DEFAULT_LOCALE ? '' : `/${locale}`}${path}`,
      lastModified: new Date().toISOString(),
      changeFrequency: 'weekly' as const,
      priority,
      alternates: {
        languages: generateAlternateUrls(path),
      },
    }))
  );
}

// Generate product pages sitemap entries
async function getProductPages() {
  try {
    const products = await getAllProducts();
    const now = new Date().toISOString();

    return products.flatMap((product) =>
      LOCALES.map((locale) => {
        const path = `/products/${product.id}`; // or use product.slug if available
        return {
          url: `${SITE_URL}${locale === DEFAULT_LOCALE ? '' : `/${locale}`}${path}`,
          lastModified: product.updatedAt || now,
          changeFrequency: 'weekly' as const,
          priority: 0.7,
          alternates: {
            languages: generateAlternateUrls(path),
          },
        };
      })
    );
  } catch (error) {
    console.error('Error generating product pages for sitemap:', error);
    return [];
  }
}

// Generate category pages sitemap entries
async function getCategoryPages() {
  try {
    const categories = await getAllCategories();
    const now = new Date().toISOString();

    return categories.flatMap((category) =>
      LOCALES.map((locale) => {
        // Use translated slug if available, otherwise fall back to default slug
        const slug = category.translations?.[locale]?.slug || category.slug;
        const path = `/catalog/${slug}`;
        
        return {
          url: `${SITE_URL}${locale === DEFAULT_LOCALE ? '' : `/${locale}`}${path}`,
          lastModified: category.updatedAt || now,
          changeFrequency: 'daily' as const,
          priority: 0.9,
          alternates: {
            languages: LOCALES.reduce((acc, lang) => ({
              ...acc,
              [lang]: `${SITE_URL}${lang === DEFAULT_LOCALE ? '' : `/${lang}`}/catalog/${category.translations?.[lang]?.slug || category.slug}`,
            }), {}),
          },
        };
      })
    );
  } catch (error) {
    console.error('Error generating category pages for sitemap:', error);
    return [];
  }
}

export default async function sitemap(): Promise<MetadataRoute.Sitemap> {
  try {
    // Fetch all data in parallel
    const [staticPages, productPages, categoryPages] = await Promise.all([
      getStaticPages(),
      getProductPages(),
      getCategoryPages(),
    ]);

    // Combine all pages and filter out any potential duplicates
    const allPages = [...staticPages, ...categoryPages, ...productPages];
    const uniquePages = Array.from(new Map(allPages.map(page => [page.url, page])).values());

    return uniquePages;
  } catch (error) {
    console.error('Error generating sitemap:', error);
    // Return at least the static pages if there's an error
    return getStaticPages();
  }
}
